apiVersion: tekton.dev/v1alpha1
kind: Task
metadata:
  name: deploy-qm
spec:
  params:
    - name: QM_NAME
      type: string
    - name: QM_POD_NAME
      type: string
    - name: TARGET_NAMESPACE
      type: string
    - name: MQ_WORKSPACE_DIR
      description: Location containing MQ configurations
      type: string
    - name: MQ_CERT_SECRET
      description: Secret to supply to the QueueManager deplyoment
    - name: MQ_PVC_SC
      type: string
  resources:
    inputs:
      - name: source
        type: git
  steps:
    - name: create-cm-apply-params-to-qm
      image: popcor255/kubectl
      workingDir: /workspace/source/$(params.MQ_WORKSPACE_DIR)
      env:
        - name: QM_NAME
          value: $(params.QM_NAME)
        - name: QM_POD_NAME
          value: $(params.QM_POD_NAME) 
        - name: TARGET_NAMESPACE
          value: $(params.TARGET_NAMESPACE)
        - name: MQ_CERT_SECRET
          value: $(params.MQ_CERT_SECRET)
        - name: MQ_PVC_SC
          value: $(params.MQ_PVC_SC)
      script: |
          set -e
          
          # Grab the Git commit tag
          TAG="$(cat ../../.git/FETCH_HEAD | awk '{print substr($1,0,7)}')"
          
          # Save it as an environment variable to create the configmap and use later in template
          export MQSC_CM_NAME=cm-$TAG
          
          # Create the config map from the supplied file in workingDir

          echo "creating config map from file config.mqsc with contents:"
          echo ""
          cat config.mqsc

          kubectl create configmap $MQSC_CM_NAME --namespace $(params.TARGET_NAMESPACE) --from-file=config.mqsc || true
          
          export SVRCONN_SNI=$(echo "${QM_NAME}" | tr '[:upper:]' '[:lower:]')2e-conn.chl.mq.ibm.com
          export SVRCONN_NAME=$(echo "${QM_NAME}" | tr '[:lower:]' '[:upper:]').CONN # in upper case
          export ROUTE_NAME="${QM_POD_NAME}-conn-traffic"

          # Stub environment variables in qm_template
          envsubst < qm_template.yaml > qm_out.yaml
          
          cat qm_out.yaml
          # Apply the QueueManager crd

          kubectl apply -f qm_out.yaml --wait=true

      securityContext:
        privileged: true
      volumeMounts:
        - mountPath: /var/lib/containers
          name: varlibcontainers
    - name: test-new-queue
      image: googlefu/apic_compiler:v3-amd64
      workingDir: /workspace/source/$(params.MQ_WORKSPACE_DIR)
      env:
        - name: QM_NAME
          value: $(params.QM_NAME)
        - name: QM_POD_NAME
          value: $(params.QM_POD_NAME) 
        - name: TARGET_NAMESPACE
          value: $(params.TARGET_NAMESPACE)
      script: |
          set -eu
          
          mq_pod="$(params.QM_NAME)-ibm-mq-0"

          echo "Waiting for MQ Pod $mq_pod to come up"
          sleep 25

          # find all queue names in the config.mqsc file in the syntax DEFINE QLOCAL('xx')
          queues=$(sed -n 's/^DEFINE QLOCAL('\''\([^'\'']*\)'\''.*$/\1/p' config.mqsc)

          msg_template="TEKTON-MSG-TO-"

          if test -z "$queues"
          then
              echo "No Queue found int config.mqsc"
          else
          # loop once to place message
          echo "$queues" | 
            while IFS= read -r queue; 
            do
            msg="${msg_template}$queue"
            echo "Sending this $msg to queue: $queue"
            printf "%s\n\n" $msg | oc exec -ti $mq_pod -n $(params.TARGET_NAMESPACE) /opt/mqm/samp/bin/amqsput $queue
          done

          #loop again to read messages

          echo "$queues" | 
            while IFS= read -r queue; 
            do

            expected="${msg_template}$queue"
            
            echo "Expecting this msg: $expected"
            
            output=$(oc exec -ti $mq_pod -n cp4i /opt/mqm/samp/bin/amqsget $queue)
            
            echo "$output" > output.txt

            match=$(grep $expected output.txt)

            if test -z "$match"
            then
              echo "Did not find expected message, exiting"
              exit 1;
            else
              echo "Found expected message! $match"
            fi
          done
          fi
      securityContext:
        privileged: true
        runAsUser: 0
      volumeMounts:
        - mountPath: /var/lib/containers
          name: varlibcontainers
  volumes:
    - emptyDir: {}
      name: varlibcontainers